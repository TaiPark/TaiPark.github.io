
<!DOCTYPE html>
<html lang class="loading">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>share - Hexo</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate">
    <meta name="keywords" content="TaiPark,"> 
    <meta name="description" content="瑞士军刀


网址
简介




nicetool
收集打造各种简单易用在线工具，无需注册和下载安装即可使用


虫部落快搜
搜索引擎大合集


好人卡简单导航
没有广告的清爽网站导航，有新世界的大,"> 
    <meta name="author" content="John Doe"> 
    <link rel="alternative" href="atom.xml" title="Hexo" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <link rel="stylesheet" href="/css/diaspora.css">
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads" src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
</head>
</html>
<body class="loading">
    <span id="config-title" style="display:none">Hexo</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="icon-home image-icon" href="javascript:;" data-url="http://yoursite.com"></a>
    <div title="播放/暂停" class="icon-play"></div>
    <h3 class="subtitle">Java并发编程小叙</h3>
    <div class="social">
        <!--<div class="like-icon">-->
            <!--<a href="javascript:;" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
        <!--</div>-->
        <div>
            <div class="share">
                <a title="获取二维码" class="icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class="main">
        <h1 class="title">Java并发编程小叙</h1>
        <div class="stuff">
            <span>一月 25, 2020</span>
            
  <ul class="post-tags-list"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/java/">java</a></li></ul>


        </div>
        <div class="content markdown">
            <h1 id="1-线程基础、线程之间的共享和协作"><a href="#1-线程基础、线程之间的共享和协作" class="headerlink" title="1.线程基础、线程之间的共享和协作"></a>1.线程基础、线程之间的共享和协作</h1><h2 id="1-1-基础概念"><a href="#1-1-基础概念" class="headerlink" title="1.1 基础概念"></a>1.1 基础概念</h2><p>CPU核心数：线程数是1:1的关系，8核CPU的一个核心对应8个线程；Inter提出超线程技术后提升为1:2，8核CPU同一时间只能运行16个线程。在实现线程时采用了CPU时间片轮转机制，所以能开很多线程，开发时要注意上下文切换对线程时间的影响。<br><strong>进程</strong>是程序运行进行资源分配的最小单位，一个进程的内部可能有多个线程，这多个线程会共享资源。<br><strong>线程</strong>是CPU调度的最小单位，它是要依附于某个进程以拥有资源。<br><strong>并行</strong>是同一时刻内同时处理的事情<br><strong>并发</strong>是指某个时间段内同时处理的事情<br>JAVA天生就是多线程的</p>
<h2 id="1-2-JAVA中的多线程"><a href="#1-2-JAVA中的多线程" class="headerlink" title="1.2 JAVA中的多线程"></a>1.2 JAVA中的多线程</h2><p>继承自类Thread启动，JAVA是单继承的，若继承自Thread类之后就无法继承其他类了，所以要添加接口<br>实现接口Runnable<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UseRun</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"runnable"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实现接口Callable，允许有返回值的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UseCall</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"runnable"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"CallResult"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException,ExecutionException</span>&#123;</span><br><span class="line">    <span class="comment">//Runnable</span></span><br><span class="line">    UseRun useRun = <span class="keyword">new</span> UseRun();</span><br><span class="line">    <span class="comment">//Runnable递交给Thread类</span></span><br><span class="line">    <span class="keyword">new</span> Thread(useRun).start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Callable</span></span><br><span class="line">    UseCall useCall = <span class="keyword">new</span> UseCall();</span><br><span class="line">    <span class="comment">//Callable必须要先包装成Runnable，FutureTask实现了Runnable接口</span></span><br><span class="line">    FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(useCall);</span><br><span class="line">    <span class="comment">//把FutureTask当做一个Runnable交给Thread</span></span><br><span class="line">    <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line">    <span class="comment">//FutureTask拿结果值</span></span><br><span class="line">    System.out.println(futureTask.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="1-3-线程的停止"><a href="#1-3-线程的停止" class="headerlink" title="1.3 线程的停止"></a>1.3 线程的停止</h2><p>早期为终止线程提出了<code>stop()</code>，<code>resume()</code>，<code>suspend()</code>三个方法，分别可以用来终止、重启、挂起线程。过于强势了，一旦调用了<code>stop()</code>会强势终结一个线程，无法保证线程资源正常释放。<code>suspend()</code>也是会占着资源进行挂起，会引起死锁问题。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> Thread(useRun);</span><br><span class="line">t.interrupt();</span><br></pre></td></tr></table></figure></p>
<p>我们应该使用<code>interrupt()</code>，<code>isInterrupted()</code>,static方法<code>interrupted()</code>，其中<code>interrupt()</code>中断一个线程，中断标志位置位true；<code>isInterrupted()</code>判定当前线程是否处于中断状态；<code>interrupted()</code>也是判定当前线程是否处于中断状态，并把中断标志位改为false。线程是协作式的，中断一个线程并不是强行关闭，而是提示其中断（中断标志位置位true），是否终止由线程决定。为了让每个线程有充分时间清理自己的工作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ch1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EndThread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UseThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UseThread</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            String threadName = Thread.currentThread().getName();</span><br><span class="line">            <span class="comment">//询问是否停止</span></span><br><span class="line">            <span class="keyword">while</span> (!isInterrupted())&#123;</span><br><span class="line">                System.out.println(threadName + <span class="string">" still run"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//打印停止后信息</span></span><br><span class="line">            System.out.println(threadName + <span class="string">" interrupt flag is "</span> + isInterrupted());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        Thread endThread = <span class="keyword">new</span> UseThread(<span class="string">"endThread"</span>);</span><br><span class="line">        endThread.start();</span><br><span class="line">        Thread.sleep(<span class="number">20</span>);</span><br><span class="line">        endThread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">endThread still run</span><br><span class="line">endThread still run</span><br><span class="line">endThread still run</span><br><span class="line">endThread still run</span><br><span class="line">endThread still run</span><br><span class="line">endThread still run</span><br><span class="line">endThread interrupt flag is true</span><br></pre></td></tr></table></figure>
<p>Runnable判定：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!Thread.currentThread().isInterrupt())&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="1-4-InterruptedException"><a href="#1-4-InterruptedException" class="headerlink" title="1.4 InterruptedException"></a>1.4 InterruptedException</h2><p>如果方法抛出InterruptedException的时候，会把线程的中断标志位复位为false。需要在catch里自行再次调用interrupt()。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ch1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EndThread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UseThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UseThread</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            String threadName = Thread.currentThread().getName();</span><br><span class="line">            <span class="comment">//询问是否停止</span></span><br><span class="line">            <span class="keyword">while</span> (!isInterrupted())&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">//被重置为false</span></span><br><span class="line">                    System.out.println(isInterrupted());</span><br><span class="line">                    <span class="comment">//再次自行停止</span></span><br><span class="line">                    interrupt();</span><br><span class="line">                    <span class="comment">//变为true，中断</span></span><br><span class="line">                    System.out.println(isInterrupted());</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//打印停止后信息</span></span><br><span class="line">            System.out.println(threadName + <span class="string">"interrupt flag is"</span> + isInterrupted());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        Thread endThread = <span class="keyword">new</span> UseThread(<span class="string">"endThread"</span>);</span><br><span class="line">        endThread.start();</span><br><span class="line">        Thread.sleep(<span class="number">20</span>);</span><br><span class="line">        endThread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">true</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">	at java.lang.Thread.sleep(Native Method)</span><br><span class="line">	at ch1.EndThread$UseThread.run(EndThread.java:15)</span><br><span class="line">endThreadinterrupt flag istrue</span><br></pre></td></tr></table></figure>
<h2 id="1-5-线程运行状态"><a href="#1-5-线程运行状态" class="headerlink" title="1.5 线程运行状态"></a>1.5 线程运行状态</h2><p><code>yield()</code>：将线程从运行态转到可运行态，其可以继续争抢运行资格<br><code>run()</code>：万物皆对象，调用run()是和调用普通方法一样的，谁调用归属哪个线程，把其打包成栈帧压进调用的虚拟机栈<br><code>start()</code>：意味着其作为单独的线程跑<br>设置优先级：1-10,缺省为5<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread.setPriority(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p>
<p>守护线程：与主线程共死的，主线程退出守护线程一定退出。（GC线程就属于守护线程）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要在start之前设置</span></span><br><span class="line">thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure></p>
<p>在守护线程中try-finally不一定起作用</p>
<h2 id="1-6-synchronized简介"><a href="#1-6-synchronized简介" class="headerlink" title="1.6 synchronized简介"></a>1.6 synchronized简介</h2><p>内置锁，锁的是<strong>具体的对象</strong>，修改的是对象头的标志位<br>对象锁和类锁<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对象锁用于对象实例方法或者对象实例上的</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">instance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//类锁用于静态方法或者类的class对象上的</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">instance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line">若锁的是不同的对象是可以同时进行的。对象锁和类锁可以同时运行。类锁锁的是每个类对应的<span class="class"><span class="keyword">class</span>对象，由虚拟机保证它是唯一的。对象锁锁的是<span class="title">new</span>出来的对象的实例。</span></span><br><span class="line"><span class="class">## 1.7 <span class="title">volatile</span>简介</span></span><br><span class="line"><span class="class">最轻量的同步机制，告诉虚拟机使用时总是从主内存中读取，在设置过之后一定要刷回主内存。其他线程对其进行更新。不会对读取、写入加锁。它不是线程安全的，只能保证可见性，不能保证其原子性。</span></span><br><span class="line"><span class="class">```<span class="title">java</span></span></span><br><span class="line"><span class="class"><span class="title">private</span> <span class="title">volatile</span> <span class="title">int</span> <span class="title">age</span> </span>= <span class="number">1000</span>;</span><br></pre></td></tr></table></figure></p>
<p>最大的用途的<strong>一写多读</strong>的场景下使用。</p>
<h2 id="1-7-ThreadLocal简介"><a href="#1-7-ThreadLocal简介" class="headerlink" title="1.7 ThreadLocal简介"></a>1.7 ThreadLocal简介</h2><p>确保每个线程使用自己的那一份拷贝。<br>赋初值<code>initialValue()</code><br>读<code>threadLocal.get()</code><br>写<code>threadLocal.set(s)</code><br>显示调用<code>threadLocal.remove()</code><br>在每个线程有自己独特的连接池时会用到。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MutiThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Integer <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StartThreadArray</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread[] runs = <span class="keyword">new</span> Thread[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; runs.length; i++)&#123;</span><br><span class="line">            runs[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> TestThread(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; runs.length; i++)&#123;</span><br><span class="line">            runs[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TestThread</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">":start"</span>);</span><br><span class="line">            <span class="comment">//获得变量的值</span></span><br><span class="line">            Integer s = threadLocal.get();</span><br><span class="line">            s += id;</span><br><span class="line">            <span class="comment">//写回去</span></span><br><span class="line">            threadLocal.set(s);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">":"</span>+threadLocal.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        MutiThread test  = <span class="keyword">new</span> MutiThread();</span><br><span class="line">        test.StartThreadArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Thread-1:start</span><br><span class="line">Thread-2:start</span><br><span class="line">Thread-0:start</span><br><span class="line">//每个线程的值都不冲突</span><br><span class="line">Thread-1:2</span><br><span class="line">Thread-2:3</span><br><span class="line">Thread-0:1</span><br></pre></td></tr></table></figure>
<p>每个线程拥有一个副本，导致其占有的内存资源是相当大的</p>
<h2 id="1-8-线程间协作"><a href="#1-8-线程间协作" class="headerlink" title="1.8 线程间协作"></a>1.8 线程间协作</h2><p>对象本身所拥有的方法：<br><code>wait()</code>【<code>sleep()</code>是线程的方法】<br><code>notify()/notifyAll()</code></p>
<p>等待和通知的标准范式：<br><strong>等待方</strong>：</p>
<ol>
<li>获取对象的锁</li>
<li>循环里判断条件是否满足，不满足调用wait()</li>
<li>条件满足，执行业务逻辑</li>
</ol>
<p><strong>通知方</strong>：</p>
<ol>
<li>获取对象的锁</li>
<li>改变条件</li>
<li>通知所有等待在对象上的线程</li>
</ol>
<p>典型的生产者消费者模型：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(mBuf.isFull())&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mBuf.add();</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(mBuf.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mBuf.remove();</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有可能的时候尽量使用<code>notifyAll()</code>,<code>notify()</code>可能有信号丢失的情况：</p>
<ul>
<li>等待池：假设一个线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁后，进入到了该对象的等待池，等待池中的线程不会去竞争该对象的锁。</li>
<li>锁池：只有获取了对象的锁，线程才能执行对象的 synchronized 代码，对象的锁每次只有一个线程可以获得，其他线程只能在锁池中等待</li>
<li>区别：notify() 方法随机唤醒对象的等待池中的一个线程，进入锁池；notifyAll() 唤醒对象的等待池中的所有线程，进入锁池。</li>
</ul>
<p><strong>等待超时模式</strong>：<br>假设等待时长为T，在now+T后超时<br>基本范式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> overtime = now + T;</span><br><span class="line"><span class="keyword">long</span> remain = T;    <span class="comment">//等待的持续时间</span></span><br><span class="line"><span class="keyword">while</span>(result不满足条件 &amp;&amp; remain &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    wait(remain);</span><br><span class="line">    remain = overtime - now;    <span class="comment">//等待剩余时间</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure></p>
<p><code>join()</code>方法：保证线程B在线程A执行完了之后执行，或者<code>CountDownLatch</code></p>
<p><code>yield()</code>方法：当前执行完了，让操作系统选择下一个时间片的线程，让出了CPU的执行权</p>
<p><code>yield()</code>、<code>sleep()</code>持有的锁不释放的<br><code>wait()</code>在调用之前必须要持有锁（synchronized），调用之后锁被释放，wait返回是又获得锁<br><code>notify()</code>在调用前必须要持有锁（synchronized），调用其本身是不会释放锁的</p>
<h1 id="2-线程开发工具类"><a href="#2-线程开发工具类" class="headerlink" title="2.线程开发工具类"></a>2.线程开发工具类</h1><h2 id="2-1-Fork-Join"><a href="#2-1-Fork-Join" class="headerlink" title="2.1 Fork-Join"></a>2.1 Fork-Join</h2><p>Fork-Join框架体现了分而治之的思想，在必要的情况下将一个大任务进行拆分成若干小任务，再讲一个个小任务join成结果。<br>分治：拆分成小问题，小问题相互独立<br>动态规划：拆分成小问题，小问题相互联系<br>Fork-Join框架提出了工作密取的概念，A线程做完了，B线程做了一半，这时候A去帮B做一部分，之后返回给B。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">MyTask myTask = <span class="keyword">new</span> ForkJoinTask();</span><br><span class="line">Pool.invoke(myTask);</span><br><span class="line">Result = myTask.join();</span><br></pre></td></tr></table></figure></p>
<p><code>MyTask</code>类必须继承自ForkJoinTask抽象类、RecursiveTask抽象类（有返回值）、RecursiveAction抽象类（无返回值）<br>要求覆盖它的<code>compute()</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRecursiveTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> beginValue;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> endValue;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">MyRecursiveTask</span><span class="params">(<span class="keyword">int</span> beginValue,<span class="keyword">int</span> endValue)</span> </span>&#123;</span><br><span class="line">	   <span class="keyword">this</span>.beginValue = beginValue;</span><br><span class="line">	   <span class="keyword">this</span>.endValue = endValue;</span><br><span class="line">   &#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> String <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(Thread.currentThread().getName()+<span class="string">"-----------"</span>);</span><br><span class="line">		<span class="keyword">if</span>(endValue -beginValue&gt;<span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> middelValue = (beginValue+endValue)/<span class="number">2</span>;</span><br><span class="line">			MyRecursiveTask leftTask = <span class="keyword">new</span> MyRecursiveTask(beginValue,middelValue);</span><br><span class="line">			MyRecursiveTask rightTask = <span class="keyword">new</span> MyRecursiveTask(middelValue+<span class="number">1</span>,endValue);</span><br><span class="line">			<span class="keyword">this</span>.invokeAll(leftTask,rightTask);</span><br><span class="line">			<span class="keyword">return</span> leftTask.join()+rightTask.join();</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			String returnString = <span class="string">""</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = beginValue;i&lt;=endValue;i++) &#123;</span><br><span class="line">				returnString = returnString+(i);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">"else 返回"</span>+returnString+<span class="string">" "</span>+beginValue+<span class="string">" "</span>+endValue);</span><br><span class="line">			<span class="keyword">return</span> returnString;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">..................................................</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	 ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">	 MyRecursiveTask taskA = <span class="keyword">new</span> MyRecursiveTask(<span class="number">1</span>,<span class="number">20</span>);</span><br><span class="line">	 ForkJoinTask&lt;String&gt; runTaskA = pool.submit(taskA);</span><br><span class="line">	 System.out.println(runTaskA.join());</span><br><span class="line">	 Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">	 </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">运行结果：</span><br><span class="line">ForkJoinPool-1-worker-3-----------</span><br><span class="line">ForkJoinPool-1-worker-3-----------</span><br><span class="line">ForkJoinPool-1-worker-3-----------</span><br><span class="line">ForkJoinPool-1-worker-3-----------</span><br><span class="line">else 返回123 1 3</span><br><span class="line">ForkJoinPool-1-worker-5-----------</span><br><span class="line">ForkJoinPool-1-worker-5-----------</span><br><span class="line">ForkJoinPool-1-worker-3-----------</span><br><span class="line">ForkJoinPool-1-worker-7-----------</span><br><span class="line">ForkJoinPool-1-worker-5-----------</span><br><span class="line">ForkJoinPool-1-worker-7-----------</span><br><span class="line">else 返回678 6 8</span><br><span class="line">ForkJoinPool-1-worker-7-----------</span><br><span class="line">else 返回910 9 10</span><br><span class="line">ForkJoinPool-1-worker-7-----------</span><br><span class="line">ForkJoinPool-1-worker-7-----------</span><br><span class="line">else 返回45 4 5</span><br><span class="line">else 返回161718 16 18</span><br><span class="line">else 返回111213 11 13</span><br><span class="line">ForkJoinPool-1-worker-7-----------</span><br><span class="line">ForkJoinPool-1-worker-3-----------</span><br><span class="line">else 返回1920 19 20</span><br><span class="line">else 返回1415 14 15</span><br><span class="line">1234567891011121314151617181920</span><br></pre></td></tr></table></figure>
<h2 id="2-2-CountDownLatch"><a href="#2-2-CountDownLatch" class="headerlink" title="2.2 CountDownLatch"></a>2.2 CountDownLatch</h2><p>一个线程等待其他的线程完成工作之后再执行，加强版的<code>join()</code>，可以规定count的数量<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span></span></span><br></pre></td></tr></table></figure></p>
<p><code>await()</code>用来负责等待<br><code>countdown()</code>用来负责减一<br>线程数与扣减数可以不一致，线程数&lt;=扣减数，可以一个线程扣减多次</p>
<h2 id="2-3-CyclicBarrier"><a href="#2-3-CyclicBarrier" class="headerlink" title="2.3 CyclicBarrier"></a>2.3 CyclicBarrier</h2><p>用一组线程到达某个屏障，然后被阻塞，一直到组内的最后一个线程到达屏障时屏障开放，所有被阻塞的线程就会继续运行。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties,Runnable barrierAction)</span></span></span><br></pre></td></tr></table></figure></p>
<p>屏障开放的时候，<code>barrierAction</code>里定义的任务会执行<br><code>await()</code>用来等待</p>
<h2 id="2-4-CountDownLatch-amp-CyclicBarrier"><a href="#2-4-CountDownLatch-amp-CyclicBarrier" class="headerlink" title="2.4 CountDownLatch &amp; CyclicBarrier"></a>2.4 CountDownLatch &amp; CyclicBarrier</h2><p><code>CountDownLatch</code>放行由第三者控制，<code>CyclicBarrier</code>放行由一组线程本身控制<br><code>CountDownLatch</code>放行条件大于等于线程数，<code>CyclicBarrier</code>放行条件等于线程数<br><code>CountDownLatch</code>不可重复，<code>CyclicBarrier</code>可重复</p>
<h2 id="2-5-Semaphore"><a href="#2-5-Semaphore" class="headerlink" title="2.5 Semaphore"></a>2.5 Semaphore</h2><p>控制同时访问某个特定资源的线程数量，最常用在流量控制上。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p><code>acquire()</code>拿许可证<br><code>tryAcquire()</code>尝试拿许可证<br><code>release()</code>还许可证<br><code>availablePermits()</code>查询当前有多少许可证可以拿<br><code>getQueueLength()</code>查询当前等待许可证的线程数量</p>
<h2 id="2-6-Callable-Future-FutureTask"><a href="#2-6-Callable-Future-FutureTask" class="headerlink" title="2.6 Callable Future FutureTask"></a>2.6 Callable Future FutureTask</h2><p>FutureTask将Callable封装成Runnable后执行<br>Future提供返回值<br><code>cancel(boolean)</code>：<br>任务没开始、任务已结束，都返回false<br><code>cancel(true)</code>中断正在运行的任务，中断成功返回true<br><code>cancel(false)</code>不回去中断已经运行的任务</p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="true">
                <source type="audio/mpeg" src>
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        <li title="0" data-url="http://m7.music.126.net/20190313150737/4e30cae567d1cab6b24edf533ccb6554/ymusic/0483/4838/35b5/7878359858baaa442edce682763addc7.mp3"></li>
                    
                        <li title="1" data-url="http://m8c.music.126.net/20190313151059/5bea8436041e778ca62d3803ff775f39/ymusic/cd09/5c39/e781/db207aa33fe7fc06b3a4cc48e55c7cf3.mp3"></li>
                    
                        <li title="2" data-url="http://m8c.music.126.net/20190313151146/a7606624c0ef4fd6e8c8e9ae41d1b1e3/ymusic/30c8/0299/3da3/d3b66580808011c0ce746a4d3bc32f25.mp3"></li>
                    
                        <li title="3" data-url="http://m8c.music.126.net/20190313151242/913a724025681bd2e7d081b6652e8789/ymusic/5f85/6204/e7dd/db0a3e79d134101a577c1329845c5055.mp3"></li>
                    
                </ul>
            
        </div>
        
    <div id="gitalk-container" class="comment link" data-ae="false" data-ci data-cs data-r data-o data-a data-d="false">查看评论</div>


    </div>
    
        <div class="side">
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-线程基础、线程之间的共享和协作"><span class="toc-number">1.</span> <span class="toc-text">1.线程基础、线程之间的共享和协作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-基础概念"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 基础概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-JAVA中的多线程"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 JAVA中的多线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-线程的停止"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 线程的停止</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-InterruptedException"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 InterruptedException</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-线程运行状态"><span class="toc-number">1.5.</span> <span class="toc-text">1.5 线程运行状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-synchronized简介"><span class="toc-number">1.6.</span> <span class="toc-text">1.6 synchronized简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-ThreadLocal简介"><span class="toc-number">1.7.</span> <span class="toc-text">1.7 ThreadLocal简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-8-线程间协作"><span class="toc-number">1.8.</span> <span class="toc-text">1.8 线程间协作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-线程开发工具类"><span class="toc-number">2.</span> <span class="toc-text">2.线程开发工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-Fork-Join"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 Fork-Join</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-CountDownLatch"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 CountDownLatch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-CyclicBarrier"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 CyclicBarrier</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-CountDownLatch-amp-CyclicBarrier"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 CountDownLatch &amp; CyclicBarrier</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-Semaphore"><span class="toc-number">2.5.</span> <span class="toc-text">2.5 Semaphore</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-Callable-Future-FutureTask"><span class="toc-number">2.6.</span> <span class="toc-text">2.6 Callable Future FutureTask</span></a></li></ol></li></ol>
        </div>
    
</div>


    </div>
</div>
<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/miku.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body>
<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/diaspora.js"></script>
<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">
<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>



<!-- Google Analytics -->
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-135683623-1', 'auto');
  ga('send', 'pageview');
</script>
<!-- End Google Analytics -->


</html>

<!--鼠标点击-->
<canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
<script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
<script type="text/javascript" src="/js/fireworks.js"></script>
